
# PIN CONSTRAINTS
Net CLK LOC=AD8  | IOSTANDARD = LVCMOS33;
Net nRST LOC=T23 | IOSTANDARD = LVCMOS33 | PULLUP;

Net BTN_N LOC=A22;
Net BTN_E LOC=A23;
Net BTN_S LOC=B22;
Net BTN_W LOC=C21;
Net BTN_C LOC=B21;

Net DIP<0> LOC=U4 | IOSTANDARD = LVCMOS18;
Net DIP<1> LOC=V3 | IOSTANDARD = LVCMOS18;
Net DIP<2> LOC=T4 | IOSTANDARD = LVCMOS18;
Net DIP<3> LOC=T5 | IOSTANDARD = LVCMOS18;
Net DIP<4> LOC=U6 | IOSTANDARD = LVCMOS18;
Net DIP<5> LOC=U5 | IOSTANDARD = LVCMOS18;
Net DIP<6> LOC=U7 | IOSTANDARD = LVCMOS18;
Net DIP<7> LOC=T7 | IOSTANDARD = LVCMOS18;

Net LED_N LOC=Y8   | IOSTANDARD = LVCMOS33;
Net LED_E LOC=Y18  | IOSTANDARD = LVCMOS33;
Net LED_S LOC=AA8  | IOSTANDARD = LVCMOS33;
Net LED_W LOC=AA18 | IOSTANDARD = LVCMOS33;
Net LED_C LOC=T22  | IOSTANDARD = LVCMOS33;

Net LED<0> LOC=E13;
Net LED<1> LOC=D14;
Net LED<2> LOC=E12;
Net LED<3> LOC=F12;
Net LED<4> LOC=D15;
Net LED<5> LOC=E15;
Net LED<6> LOC=E10;
Net LED<7> LOC=E11;

NET "EN"         LOC = P6 | IOSTANDARD = LVCMOS33;
NET "LCDDATA[0]" LOC = R6 | IOSTANDARD = LVCMOS33;
NET "LCDDATA[1]" LOC = T3 | IOSTANDARD = LVCMOS33;
NET "LCDDATA[2]" LOC = R3 | IOSTANDARD = LVCMOS33;
NET "LCDDATA[3]" LOC = P4 | IOSTANDARD = LVCMOS33;
NET "RS"         LOC = R7 | IOSTANDARD = LVCMOS33;
NET "RW"         LOC = R5 | IOSTANDARD = LVCMOS33;

# PlanAhead generated physical constraints

NET "CLK_33MHZ_FPGA" LOC = AB12 | IOSTANDARD = LVCMOS33;

NET "MPA[0]"  LOC = N6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[1]"  LOC = E5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[2]"  LOC = F5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[3]"  LOC = F4 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[4]"  LOC = J5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[5]"  LOC = E7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPA[6]"  LOC = G7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 25 ns VALID 10ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPD[0]"  LOC = M6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[1]"  LOC = K5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[2]"  LOC = L3 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[3]"  LOC = L4 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[4]"  LOC = L7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[5]"  LOC = L5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[6]"  LOC = H6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[7]"  LOC = G5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[8]"  LOC = M7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[9]"  LOC = H7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[10]" LOC = J6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[11]" LOC = G4 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[12]" LOC = K7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[13]" LOC = J4 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[14]" LOC = H4 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "MPD[15]" LOC = K6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7 ns VALID 30 ns BEFORE "CLK_33MHZ_FPGA" | OFFSET = OUT 25 ns VALID 10 ns AFTER  "CLK_33MHZ_FPGA";
NET "nMPCE"   LOC = F7 | IOSTANDARD = LVCMOS33 | SLEW = FAST;
NET "nMPWE"   LOC = M5 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 17ns AFTER "CLK_33MHZ_FPGA";
NET "nMPOE"   LOC = E6 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = OUT 12ns AFTER "CLK_33MHZ_FPGA"; 
NET "MPBRDY"  LOC = N7 | IOSTANDARD = LVCMOS33 | SLEW = FAST | OFFSET = IN 7ns BEFORE "CLK_33MHZ_FPGA";
NET "MPIRQ"   LOC = G6 | IOSTANDARD = LVCMOS33 | SLEW = FAST;

NET "DA2[4]"     LOC = J20  | IOSTANDARD = LVCMOS25;
NET "DA2[5]"     LOC = J23  | IOSTANDARD = LVCMOS25;
NET "DA2[6]"     LOC = J21  | IOSTANDARD = LVCMOS25;
NET "DA2[7]"     LOC = H23  | IOSTANDARD = LVCMOS25;
NET "DA2[8]"     LOC = M22  | IOSTANDARD = LVCMOS25;
NET "DA2[9]"     LOC = K20  | IOSTANDARD = LVCMOS25;

NET "DACLK"      LOC = K21  | IOSTANDARD = LVCMOS25;

NET "DA1[9]"     LOC = M21  | IOSTANDARD = LVCMOS25;
NET "DA1[8]"     LOC = L25  | IOSTANDARD = LVCMOS25;
NET "DA1[7]"     LOC = L24  | IOSTANDARD = LVCMOS25;
NET "DA1[6]"     LOC = K26  | IOSTANDARD = LVCMOS25;
NET "DA1[5]"     LOC = K25  | IOSTANDARD = LVCMOS25;
NET "DA1[4]"     LOC = M26  | IOSTANDARD = LVCMOS25;

NET "ADN[0]"     LOC = J26  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[0]"     LOC = J25  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[1]"     LOC = R23  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[1]"     LOC = R22  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[2]"     LOC = N21  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[2]"     LOC = N22  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[3]"     LOC = U26  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[3]"     LOC = V26  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "DCON"       LOC = K22  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE" | CLOCK_DEDICATED_ROUTE = FALSE;
NET "DCOP"       LOC = K23  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE" | CLOCK_DEDICATED_ROUTE = FALSE;
NET "ADN[4]"     LOC = H26  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[4]"     LOC = G26  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[5]"     LOC = L19  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[5]"     LOC = L20  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[6]"     LOC = N23  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[6]"     LOC = P23  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADN[7]"     LOC = G25  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADP[7]"     LOC = G24  | IOSTANDARD = LVDS_25 | DIFF_TERM = "TRUE";
NET "ADC_nOE"    LOC = M19  | IOSTANDARD = LVCMOS25;
NET "SCLK"       LOC = M20  | IOSTANDARD = LVCMOS25;
NET "SDIO"       LOC = J24  | IOSTANDARD = LVCMOS25;
NET "CSB"        LOC = H24  | IOSTANDARD = LVCMOS25;
NET "ADCLKP"     LOC = P20  | IOSTANDARD = LVDS_25 | DRIVE=24 | SLEW=FAST;
NET "ADCLKN"     LOC = P21  | IOSTANDARD = LVDS_25 | DRIVE=24 | SLEW=FAST;

NET "CLK_33MHZ_FPGA" TNM_NET = CLK_33MHZ_FPGA;
TIMESPEC TS_CLK_33MHZ_FPGA = PERIOD "CLK_33MHZ_FPGA" 33 ns HIGH 50%;
NET "CLK" TNM_NET = "CLK";
TIMESPEC TS_CLK = PERIOD "CLK" 10 ns HIGH 50%;

NET "DCOP" TNM_NET = DCOP;
TIMESPEC TS_DCOP = PERIOD "DCOP" 4.16 ns HIGH 50%;
NET "DCON" TNM_NET = DCON;
TIMESPEC TS_DCON = PERIOD "DCON" TS_DCOP PHASE 2.08 ns HIGH 50%;

# NET "DCOP" TNM_NET = "DCOP";
# TIMESPEC TS_DCOP = PERIOD "DCOP" TS_pll2_CLKOUT0_BUF PHASE + 3.7 ns HIGH 50%;

# NET "DCON" TNM_NET = "DCON";
# TIMESPEC TS_DCON = PERIOD "DCON" TS_DCOP PHASE + 2.08 ns;

# DDR

NET ddr2_a<0>  LOC = Y5; # DDR_A0
NET ddr2_a<1>  LOC = Y6; # DDR_A1
NET ddr2_a<2>  LOC = W6; # DDR_A2
NET ddr2_a<3>  LOC = W5; # DDR_A3
NET ddr2_a<4>  LOC = V7; # DDR_A4
NET ddr2_a<5>  LOC = V6; # DDR_A5
NET ddr2_a<6>  LOC = Y3; # DDR_A6
NET ddr2_a<7>  LOC = W3; # DDR_A7
NET ddr2_a<8>  LOC = W4; # DDR_A8
NET ddr2_a<9>  LOC = V4; # DDR_A9
NET ddr2_a<10> LOC = AD3; # DDR_A10
NET ddr2_a<11> LOC = AD4; # DDR_A11
NET ddr2_a<12> LOC = AC3; # DDR_A12
NET ddr2_ba<0>  LOC = AB5; # DDR_BA0
NET ddr2_ba<1>  LOC = AB6; # DDR_BA1
NET ddr2_cas_n   LOC = AE3; # DDR_CAS_N
NET ddr2_cke<0> LOC = AA3; # DDR_CKE
NET ddr2_cke<1> LOC = AB4; # DDR_CKE
NET ddr2_cs_n<0>  LOC = AF3; # DDR_CS_N
NET ddr2_cs_n<1>  LOC = AD6; # DDR_CS_N
NET ddr2_ras_n   LOC = AC6; # DDR_RAS_N
NET ddr2_we_n    LOC = AB7; # DDR_WE_N
NET ddr2_ck<0>    LOC = E2; # DDR_CK0_P
NET ddr2_ck_n<0>   LOC = E1; # DDR_CK0_N
NET ddr2_ck<1>    LOC = P1; # DDR_CK1_P
NET ddr2_ck_n<1>   LOC = R1; # DDR_CK1_N
NET ddr2_odt<0>  LOC =AE6; # DDR_ODT0
NET ddr2_odt<1>  LOC =AE5; # DDR_ODT1

NET ddr2_dm<0>  LOC = B9; # DDR_DM0
NET ddr2_dm<1>  LOC = A8; # DDR_DM1
NET ddr2_dm<2>  LOC = C4; # DDR_DM2
NET ddr2_dm<3>  LOC = F2; # DDR_DM3
NET ddr2_dm<4>  LOC = AB1; # DDR_DM4
NET ddr2_dm<5>  LOC = AF24; # DDR_DM5
NET ddr2_dm<6>  LOC = AF22; # DDR_DM6
NET ddr2_dm<7>  LOC = AF8; # DDR_DM7

NET ddr2_dqs<0>  LOC = B7; # DDR_DQS0
NET ddr2_dqs_n<0> LOC = A7; # DDR_DQSN0
NET ddr2_dqs<1>  LOC = D5; # DDR_DQS1
NET ddr2_dqs_n<1> LOC = D6; # DDR_DQSN1
NET ddr2_dqs<2>  LOC = C6; # DDR_DQS2
NET ddr2_dqs_n<2> LOC = C7; # DDR_DQSN2
NET ddr2_dqs<3>  LOC = M1; # DDR_DQS3
NET ddr2_dqs_n<3> LOC = N1; # DDR_DQSN3
NET ddr2_dqs<4>  LOC = T2; # DDR_DQS4
NET ddr2_dqs_n<4> LOC = R2; # DDR_DQSN4
NET ddr2_dqs<5>  LOC = AF18; # DDR_DQS5
NET ddr2_dqs_n<5> LOC = AE18; # DDR_DQSN5
NET ddr2_dqs<6>  LOC = AF19; # DDR_DQS6
NET ddr2_dqs_n<6> LOC = AF20; # DDR_DQSN6
NET ddr2_dqs<7>  LOC = AF17; # DDR_DQS7
NET ddr2_dqs_n<7> LOC = AE17; # DDR_DQSN7

NET ddr2_dq<0> LOC = C11; # DDR_D0
NET ddr2_dq<1> LOC = C13; # DDR_D1
NET ddr2_dq<2> LOC = A12; # DDR_D2
NET ddr2_dq<3> LOC = C9; # DDR_D3
NET ddr2_dq<4> LOC = D10; # DDR_D4
NET ddr2_dq<5> LOC = C12; # DDR_D5
NET ddr2_dq<6> LOC = B12; # DDR_D6
NET ddr2_dq<7> LOC = A13; # DDR_D7
NET ddr2_dq<8> LOC = A10; # DDR_D8
NET ddr2_dq<9> LOC = A9; # DDR_D9
NET ddr2_dq<10> LOC = B5; # DDR_D10
NET ddr2_dq<11> LOC = D3; # DDR_D11
NET ddr2_dq<12> LOC = B10; # DDR_D12
NET ddr2_dq<13> LOC = B11; # DDR_D13
NET ddr2_dq<14> LOC = B6; # DDR_D14
NET ddr2_dq<15> LOC = B4; # DDR_D15
NET ddr2_dq<16> LOC = C2; # DDR_D16
NET ddr2_dq<17> LOC = A2; # DDR_D17
NET ddr2_dq<18> LOC = D1; # DDR_D18
NET ddr2_dq<19> LOC = B1; # DDR_D19
NET ddr2_dq<20> LOC = C3; # DDR_D20
NET ddr2_dq<21> LOC = A3; # DDR_D21
NET ddr2_dq<22> LOC = C1; # DDR_D22
NET ddr2_dq<23> LOC = B2; # DDR_D23
NET ddr2_dq<24> LOC = F3; # DDR_D24
NET ddr2_dq<25> LOC = G1; # DDR_D25
NET ddr2_dq<26> LOC = G2; # DDR_D26
NET ddr2_dq<27> LOC = H3; # DDR_D27
NET ddr2_dq<28> LOC = E3; # DDR_D28
NET ddr2_dq<29> LOC = H1; # DDR_D29
NET ddr2_dq<30> LOC = K3; # DDR_D30
NET ddr2_dq<31> LOC = J3; # DDR_D31

NET ddr2_dq<32> LOC = Y1; # DDR_D32
NET ddr2_dq<33> LOC = Y2; # DDR_D33
NET ddr2_dq<34> LOC = AC1; # DDR_D34
NET ddr2_dq<35> LOC = AD1; # DDR_D35
NET ddr2_dq<36> LOC = AA2; # DDR_D36
NET ddr2_dq<37> LOC = AB2; # DDR_D37
NET ddr2_dq<38> LOC = AC2; # DDR_D38
NET ddr2_dq<39> LOC = AE1; # DDR_D39
NET ddr2_dq<40> LOC = AD23; # DDR_D40
NET ddr2_dq<41> LOC = AD26; # DDR_D41
NET ddr2_dq<42> LOC = AF25; # DDR_D42
NET ddr2_dq<43> LOC = AD25; # DDR_D43
NET ddr2_dq<44> LOC = AD24; # DDR_D44
NET ddr2_dq<45> LOC = AE26; # DDR_D45
NET ddr2_dq<46> LOC = AE25; # DDR_D46
NET ddr2_dq<47> LOC = AF23; # DDR_D47
NET ddr2_dq<48> LOC = AD20; # DDR_D48
NET ddr2_dq<49> LOC = AE20; # DDR_D49
NET ddr2_dq<50> LOC = AF14; # DDR_D50
NET ddr2_dq<51> LOC = AF12; # DDR_D51
NET ddr2_dq<52> LOC = AD21; # DDR_D52
NET ddr2_dq<53> LOC = AE21; # DDR_D53
NET ddr2_dq<54> LOC = AF13; # DDR_D54
NET ddr2_dq<55> LOC = AE12; # DDR_D55
NET ddr2_dq<56> LOC = AE11; # DDR_D56
NET ddr2_dq<57> LOC = AE10; # DDR_D57
NET ddr2_dq<58> LOC = AF7; # DDR_D58
NET ddr2_dq<59> LOC = AE7; # DDR_D59
NET ddr2_dq<60> LOC = AF10; # DDR_D60
NET ddr2_dq<61> LOC = AF9; # DDR_D61
NET ddr2_dq<62> LOC = AE8; # DDR_D62
NET ddr2_dq<63> LOC = AD9; # DDR_D63

NET ddr2_a<*>   IOSTANDARD = SSTL18_II;
NET ddr2_ba<*>   IOSTANDARD = SSTL18_II;
NET ddr2_cke<*>  IOSTANDARD = SSTL18_II;
NET ddr2_cas_n    IOSTANDARD = SSTL18_II;
NET ddr2_cs_n<*>  IOSTANDARD = SSTL18_II;
NET ddr2_ras_n    IOSTANDARD = SSTL18_II;
NET ddr2_we_n     IOSTANDARD = SSTL18_II;
NET ddr2_odt<*>  IOSTANDARD = SSTL18_II;

NET ddr2_dm<*>   IOSTANDARD = SSTL18_II_DCI;
NET ddr2_dq<*>   IOSTANDARD = SSTL18_II_DCI;

NET ddr2_ck<*>  IOSTANDARD = DIFF_SSTL18_II;
NET ddr2_ck_n<*> IOSTANDARD = DIFF_SSTL18_II;
NET ddr2_dqs<*>  IOSTANDARD = DIFF_SSTL18_II_DCI;
NET ddr2_dqs_n<*> IOSTANDARD = DIFF_SSTL18_II_DCI;

############################################################################
# Clock constraints                                                        #
############################################################################

# NET "clk266" TNM_NET = "SYS_clk0";
# TIMESPEC "TS_SYS_clk0" = PERIOD "SYS_clk0" 3.75 ns HIGH 50 %;

# NET "clk266_90" TNM_NET = "SYS_clk90";
# TIMESPEC "TS_SYS_clk90" = PERIOD "SYS_clk90" "TS_SYS_clk0" PHASE 0.938 ns HIGH 50 %;

# NET "clk133" TNM_NET = "SYS_clkdiv0";
# TIMESPEC "TS_SYS_clkdiv0" = PERIOD "SYS_clkdiv0" "TS_SYS_clk0" * 2 HIGH 50 %;

# NET "clk200" TNM_NET = "SYS_clk200";
# TIMESPEC "TS_SYS_clk200" = PERIOD "SYS_clk200" 5 ns HIGH 50 %;

########################################################################
# Controller 0
# Memory Device: DDR2_SDRAM->SODIMMs->MT4HTF3264HY-53E
# Data Width:     64
# Frequency:      266.667
# Time Period:      3750
# Data Mask:     1
########################################################################

###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################

# MIG 2.1: Eliminate Timegroup definitions for CLK0, and CLK90. Instead trace
#          multicycle paths from originating flip-flop to ANY destination
#          flip-flop (or in some cases, it can also be a BRAM)
# MUX Select for either rising/falling CLK0 for 2nd stage read capture
INST "*/u_phy_calib/gen_rd_data_sel*.u_ff_rd_data_sel" TNM = "TNM_RD_DATA_SEL";
TIMESPEC "TS_MC_RD_DATA_SEL" = FROM "TNM_RD_DATA_SEL" TO FFS
"TS_pll3_CLKOUT1_BUF" * 4;
# MUX select for read data - optional delay on data to account for byte skews
INST "*/u_usr_rd/gen_rden_sel_mux*.u_ff_rden_sel_mux" TNM = "TNM_RDEN_SEL_MUX";
TIMESPEC "TS_MC_RDEN_SEL_MUX" = FROM "TNM_RDEN_SEL_MUX" TO FFS
"TS_pll3_CLKOUT1_BUF" * 4;
# Calibration/Initialization complete status flag (for PHY logic only) - can
# be used to drive both flip-flops and BRAMs
INST "*/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_DATA_SEL";
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_0" = FROM "TNM_PHY_INIT_DATA_SEL" TO FFS
"TS_pll3_CLKOUT1_BUF" * 4;
TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_90" = FROM "TNM_PHY_INIT_DATA_SEL" TO RAMS
"TS_pll3_CLKOUT1_BUF" * 4;
# Select (address) bits for SRL32 shift registers used in stage3/stage4
# calibration
INST "*/u_phy_calib/gen_gate_dly*.u_ff_gate_dly" TNM = "TNM_GATE_DLY";
TIMESPEC "TS_MC_GATE_DLY" = FROM "TNM_GATE_DLY" TO FFS "TS_pll3_CLKOUT1_BUF" * 4;

INST "*/u_phy_calib/gen_rden_dly*.u_ff_rden_dly" TNM = "TNM_RDEN_DLY";
TIMESPEC "TS_MC_RDEN_DLY" = FROM "TNM_RDEN_DLY" TO FFS "TS_pll3_CLKOUT1_BUF" * 4;

INST "*/u_phy_calib/gen_cal_rden_dly*.u_ff_cal_rden_dly"
  TNM = "TNM_CAL_RDEN_DLY";
TIMESPEC "TS_MC_CAL_RDEN_DLY" = FROM "TNM_CAL_RDEN_DLY" TO FFS
"TS_pll3_CLKOUT1_BUF" * 4;

############################################################################### 
#The following constraint is added to prevent (false) hold time violations on
#the data path from stage1 to stage2 capture flops.  Stage1 flops are clocked by 
#the delayed DQS and stage2 flops are clocked by the clk0 clock. Placing a TIG 
#on the DQ IDDR capture flop instance to achieve this is acceptable because timing
#is guaranteed through the use of separate Predictable IP constraints. These
#violations are reported when anunconstrained path report is run.	  
############################################################################### 
INST "*/gen_dq[*].u_iob_dq/gen*.u_iddr_dq" TIG ;
###############################################################################
# DQS Read Post amble Glitch Squelch circuit related constraints
###############################################################################

###############################################################################
# LOC placement of DQS-squelch related IDDR and IDELAY elements
# Each circuit can be located at any of the following locations:
#  1. Unused "N"-side of DQS differential pair I/O
#  2. DM data mask (output only, input side is free for use)
#  3. Any output-only site
###############################################################################

###############################################################################
#The following constraint is added to avoid the HOLD violations in the trace report
#when run for unconstrained paths.These two FF groups will be clocked by two different
# clocks and hence there should be no timing analysis performed on this path.
###############################################################################
INST "*/u_mem_if_top/u_phy_top/u_phy_io/u_phy_calib/gen_gate[*].u_en_dqs_ff" TNM = EN_DQS_FF;
TIMESPEC TS_FROM_EN_DQS_FF_TO_DQ_CE_FF = FROM EN_DQS_FF TO TNM_DQ_CE_IDDR 3.85 ns DATAPATHONLY;

INST "*/gen_dqs[0].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y180";
INST "*/gen_dqs[0].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y180";
INST "*/gen_dqs[1].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y178";
INST "*/gen_dqs[1].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y178";
INST "*/gen_dqs[2].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y176";
INST "*/gen_dqs[2].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y176";
INST "*/gen_dqs[3].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y102";
INST "*/gen_dqs[3].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y102";
INST "*/gen_dqs[4].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X2Y96";
INST "*/gen_dqs[4].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X2Y96";
INST "*/gen_dqs[5].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y22";
INST "*/gen_dqs[5].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y22";
INST "*/gen_dqs[6].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y20";
INST "*/gen_dqs[6].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y20";
INST "*/gen_dqs[7].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y18";
INST "*/gen_dqs[7].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y18";

###############################################################################
# LOC and timing constraints for flop driving DQS CE enable signal
# from fabric logic. Even though the absolute delay on this path is
# calibrated out (when synchronizing this output to DQS), the delay
# should still be kept as low as possible to reduce post-calibration
# voltage/temp variations - these are roughly proportional to the
# absolute delay of the path.                                    
#	The following code has been commented for V5 as the predictable IP will take 
#	care of placement of these flops by meeting the MAXDELAY requirement.  
#	These constraints will be removed in the next release.  
###############################################################################

INST "*/u_phy_calib/gen_gate[0].u_en_dqs_ff"  LOC = SLICE_X51Y90;
INST "*/u_phy_calib/gen_gate[1].u_en_dqs_ff"  LOC = SLICE_X51Y89;
INST "*/u_phy_calib/gen_gate[2].u_en_dqs_ff"  LOC = SLICE_X51Y88;
INST "*/u_phy_calib/gen_gate[3].u_en_dqs_ff"  LOC = SLICE_X51Y51;
INST "*/u_phy_calib/gen_gate[4].u_en_dqs_ff"  LOC = SLICE_X51Y48;
INST "*/u_phy_calib/gen_gate[5].u_en_dqs_ff"  LOC = SLICE_X0Y11;
INST "*/u_phy_calib/gen_gate[6].u_en_dqs_ff"  LOC = SLICE_X0Y10;
INST "*/u_phy_calib/gen_gate[7].u_en_dqs_ff"  LOC = SLICE_X0Y9;

# Control for DQS gate - from fabric flop. Prevent "runaway" delay -
# two parts to this path: (1) from fabric flop to IDELAY, (2) from
# IDELAY to asynchronous reset of IDDR that drives the DQ CE's
# This can be relaxed by the user for lower frequencies:
# 300MHz = 850ps, 267MHz = 900ps. At 200MHz = 950ps.
# In general PAR should be able to route this
# within 900ps over all speed grades.
NET "*/u_phy_io/en_dqs[*]" MAXDELAY = 600 ps;
NET "*/u_phy_io/gen_dqs*.u_iob_dqs/en_dqs_sync" MAXDELAY = 850 ps;

###############################################################################
# "Half-cycle" path constraint from IOB flip-flop to CE pin for all DQ IDDR's
# for DQS Read Post amble Glitch Squelch circuit
###############################################################################

# Max delay from output of IOB flip-flop to CE input of DQ IDDRs =
#  tRPST + some slack where slack account for rise-time of DQS on board.
#  For now assume slack = 0.400ns (based on initial SPICE simulations,
#  assumes use of ODT), so time = 0.4*Tcyc + 0.40ns = 1.6ns @333MHz
INST "*/gen_dqs[*].u_iob_dqs/u_iddr_dq_ce" TNM = "TNM_DQ_CE_IDDR";
INST "*/gen_dq[*].u_iob_dq/gen_stg2_*.u_iddr_dq" TNM = "TNM_DQS_FLOPS";
TIMESPEC "TS_DQ_CE" = FROM "TNM_DQ_CE_IDDR" TO "TNM_DQS_FLOPS" 1.9 ns;

NET "*BU2/U0/grf.rf/*" TIG;
NET "*BU2/U0/grf.rf/*" TIG;
# NET "test_async_ddr/state_FSM_FFd2" TIG;
NET "*reader*/start_l" TIG;
# NET "*reader/bottom_l" TIG;

NET "ADP[*]" OFFSET = IN -0.1 ns VALID 1.7 ns BEFORE "DCOP" RISING;
NET "ADN[*]" OFFSET = IN -0.1 ns VALID 1.7 ns BEFORE "DCOP" RISING;
NET "ADP[*]" OFFSET = IN -0.1 ns VALID 1.7 ns BEFORE "DCOP" FALLING;
NET "ADN[*]" OFFSET = IN -0.1 ns VALID 1.7 ns BEFORE "DCOP" FALLING;

INST "*idelayctrl_adc1" LOC = IDELAYCTRL_X0Y2;
INST "*idelayctrl_adc2" LOC = IDELAYCTRL_X0Y3;

INST "*dq_oe_n_1" LOC = SLICE_X29Y39;
INST "*dq_oe_n_0" LOC = SLICE_X29Y39;

INST "adc_sync_inst" AREA_GROUP = "pblock_adc_sync_inst";
AREA_GROUP "pblock_adc_sync_inst" RANGE=SLICE_X0Y45:SLICE_X1Y79;
